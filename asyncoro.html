<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8" /> 
    <meta name="description" content="Python module for distributing computations across multiple processors on a single machine, among many machines in a cluster, grid or cloud. The computations can be standalone programs or python functions." /> 
    <meta name="keywords" content="dispy, python, parallel processing, distributed computing, cluster computing" /> 
    <title> 
      asyncoro - Framework for Asynchronous, Concurrent Programming
    </title> 

<link rel="stylesheet" type="text/css" href="style.css" />
 
  </head> 
  <body> 
    <center><h4>asyncoro : Framework for Asynchronous, Concurrent Programming</h4></center>
    <div id="content-mask">
      <div id="content-container"> 
	<div id="content-menu">
	  <ul>
            <li><a href="index.html">Project Page</a></li> 
            <li><a href="dispy.html">dispy</a></li> 
            <li><a href="dispynode.html">dispynode</a></li> 
            <li><a href="dispyscheduler.html">dispyscheduler</a></li> 
            <li><a href="dispynetrelay.html">dispynetrelay</a></li>
	  </ul>
	  <hr />
	  <ul>
            <li><a href="http://sourceforge.net/projects/dispy/files">Download dispy</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/">Project details</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/support">Get support</a></li>
	  </ul>
	</div> 

	<div id="content-wrap"> 
	  <div id="content"> 

<center><h2>asyncoro</h2></center>
<p>
  asyncoro is an independent Python framework for developing
  concurrent programs with asynchronous completions and
  coroutines. Asynchronous completions currently implemented in
  asyncoro are socket I/O operations (for non-blocking sockets),
  database cursors, sleep timers and locking primitives.  The
  coroutines should use <em>yield</em> with these completions. Each
  yield statement gives control to asyncoro's scheduler, which
  interleaves executions of coroutines, similar to the way an
  operating system executes multiple processes. Programs developed
  with asyncoro have same logic and structure as programs with
  threads, except for a few syntactic changes. asyncoro supports
  socket I/O notification mechanisms epoll, kqueue, /dev/poll (and
  poll and select, where necessary), and Windows I/O Completion Ports
  (IOCP) for high performance and scalability, and SSL for security.
  asyncoro is a <a href="asyncoro.sourceforge.net">separate
  project</a> independent of dispy, but distributed with dispy.</p>

<h4>Details</h4>
<p>

Traditional methods of threads and synchronous sockets have many
drawbacks, especially with Python due to global interpreter lock (GIL)
that forces only one active thread of execution. This approach is not
suited for large number of concurrent connections, known
as <a href="http://www.kegel.com/c10k.html">C10K problem</a>. In
addition, threads in Python have both memory and time overheads,
especially on multi-core systems
(see <a href="http://www.dabeaz.com/python/GIL.pdf">Inside the Python
GIL</a>).</p>

<p>
  Many <a href="http://nichol.as/asynchronous-servers-in-python">asynchronous
  frameworks</a> are now available to deal with this problem. Unlike
  these frameworks, asyncoro framework is very similar to the thread
  based programming so that there is almost no learning curve -
  existing thread implementations can be converted to asyncoro almost
  mechanically (although it cannot be automated). In fact, it may be
  easier to use asyncoro than threads, as locking is not required with
  asyncoro (see below). Moreover, asyncoro framework is very small
  (about 2000 lines in a single file 'asyncoro.py'), so it is easy to
  understand how it works and how to program with it. While not
  required to program with asyncoro,
  <a href="http://www.dabeaz.com/coroutines/index.html">A Curious
  Course on Coroutines and Concurrency</a> offers details on generator
  functions and coroutines.
</p>

<p>
For example, a simple tcp server with asyncoro looks like:
</p>
<code>def process(sock, coro=None):
    # convert sock to asynchronous socket
    sock = AsynCoroSocket(sock)
    # get (exactly) 4MB of data, for example, and let other coroutines
    # (process methods, in this case) execute in the meantime
    data = yield sock.recvall(4096*1024)
    # ...
    yield sock.sendall(reply)
    sock.close()

if __name__ == '__main__':
    host, port = '', 3456
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(128)
    while True:
        conn, addr = sock.accept()
        Coro(process, conn)
</code>

<p>
Here we mixed synchronous sockets in server loop and asynchronous
sockets in the <em>process</em> method for illustration. The server
does not do any processing, so the loop can quickly accept
connections. Each request is processed in a separate coroutine. Note
that I/O event loop is transparent - asyncoro's scheduler handles I/O
events automatically. A coroutine should have <em>coro=None</em>
default argument. The coroutine builder Coro (which is similar to
threading.Thread) will set coro argument with the Coro instance, which
can used for calling methods in Coro class (see below). In the
<em>process</em> method, socket I/O operations are called with
<em>yield</em>. With these statements, the I/O operation is initiated
and control goes to asyncoro's scheduler for scheduling other
coroutines as well as processing I/O events. When an I/O operation is
complete, the scheduler returns the results of the I/O operation back
to the method. During the time it takes to complete an I/O operation,
the scheduler executes other coroutines (in this case,
other <em>process</em> coroutines).
</p>

<h4>API</h4>
<p>
  asyncoro framework consists of AsynCoro scheduler, Coro factory to
  create coroutines from generator functions, AsynCoroSocket to
  convert regular synchronous sockets to asynchronous (non-blocking)
  sockets, AsynCoroDBCursor to convert database cursor
  operations <em>execute</em>, <em>executemany</em>
  and <em>callproc</em> to asynchronous operations, and locking,
  condition, event, semaphore primitives similar to thread
  primitives. asyncoro has been tested with Python versions 2.7 and
  3.2 under Linux, OS X and Windows. Under Windows asyncoro uses IOCP
  only
  if <a href="https://sourceforge.net/projects/pywin32/files/pywin32/">Python
  for Windows Extensions</a> (pywin32) is installed. pywin32 works
  with Windows 32-bit and 64-bit.
  </p>

<ul>
  <li>
    <b>AsynCoro</b> is a (singleton) scheduler that runs coroutines
    similar to operating system's scheduler that runs multiple
    processes. It is initialized automatically when a coroutine is
    created. If necessary, the scheduler instance can be obtained
    with <tt>AsynCoro()</tt> or <tt>AsynCoro.instance()</tt>. The
    scheduler runs in a separate thread from user program. It has
    three methods:
    <ul>
      <li>
	<b>cur_coro()</b> method returns coroutine (instance of Coro)
	being executed. As mentioned below, coroutines
	have <em>coro</em> variable (parameter to generator function,
	to be specific) that can be used more efficiently instead.
      </li>
      <li>
	<b>join()</b> method waits for all scheduled non-daemon
	coroutines to finish. After join returns, more coroutines can
	be created (which are added to scheduler).
      </li>
      <li>
	<b>terminate()</b> method terminates all scheduled
	coroutines and then the scheduler itself. If necessary, a new
	scheduler instance may be created with <tt>AsynCoro()</tt>
	or <tt>AsynCoro.instance()</tt>.
      </li>
    </ul>
    </li>
  <li>Threads in synchronous programs can be replaced with coroutines
    using asyncoro's <b>Coro</b> class (i.e., Coro replaces
    threading.Thread). <tt>Coro(target[, arg1, arg2, ...])</tt>
    creates a coroutine. <em>target</em> must be a generator function
    (a function with <em>yield</em>
    statements). <em>arg1</em>, <em>arg2</em> etc. are arguments or
    keyword arguments to <em>target</em>. <em>target</em> generator
    function must have <em>coro=None</em> keyword argument. Coro
    instantiation replaces <em>None</em> with the instance of Coro, so
    coroutine can use this to invoke methods in Coro class (see
    below). Consider the generator function (where <em>sock</em> is
    asynchronous socket and all statements are asynchronous, so all
    are used with <em>yield</em>)

    <code>def get_reply(sock, msg, coro=None):
    yield sock.sendall(msg)
    yield coro.sleep(1)
    yield sock.recv(1024)</code>
    It can be made a coroutine with
    <tt>Coro(get_reply, conn, "ping")</tt> so that generator function
    get_reply is called with <tt>sock=conn,
    msg="ping"</tt>. <em>coro</em> keyword argument is automatically
    supplied by Coro; it should not be in the arguments to Coro. When
    a coroutine is created with Coro, it is added to AsynCoro
    scheduler and starts executing - there is no need to start it
    explicitly, as done with threads. Note that generator functions
    cannot use <em>return</em> statement. With asyncoro, a <tt>raise
    StopIteration(v)</tt> effectively serves as <tt>return v</tt>. If
    a generator/coroutine does not use StopIteration, then the last
    value yielded in the generator becomes the return value. Thus, in
    the example above <em>get_reply</em> does not use StopIteration,
    so buffer received (in the last <em>yield</em>) is equivalent to
    return value of <em>get_reply</em>.
    </li>
  <li>Within a coroutine, <em>coro</em> variable refers to the
  coroutine (instance of Coro class). This variable can be used to
  invoke methods of Coro class, use it in other coroutines, for
  example, to wakeup from sleep etc. A coroutine has following
  methods:
    <ul>
      <li><b>suspend(timeout=None, alarm_value=None)</b> method should
      be used with <em>yield</em> statement. <b>sleep</b>
      and <b>receive</b> are synonyms for <em>suspend</em>. If
      timeout is a positive number (float or int), AsynCoro suspends
      execution of coroutine until that many seconds (or fractions of
      second). If timeout is None, the coroutine is not woken up by
      AsynCoro - some other coroutine needs to resume it. The value
      yielded by this method is the value it is resumed with or
      alarm_value if resumed by AsynCoro due to timeout.  For example,
      if a coroutine executes <tt>v = yield coro.sleep(2.9)</tt>, it
      is suspended for 2.9 seconds. If before timeout, another
      coroutine wakes up this coroutine (with
      <em>resume</em> method) with a value, <em>v</em> is set to that
      value. Otherwise, after 2.9 seconds, this coroutine is resumed
      with None (default alarm_value) so <em>v</em> is set to None and
      coroutine continues execution. During the time coroutine is
      suspended, scheduler executes other scheduled coroutines. Within
      a coroutine coro.sleep must be used (with <em>yield</em>)
      instead of time.sleep. If called with timeout=0, this method
      will not suspend the coroutine; it will return either earliest
      'update' from resume queue if any available or alarm_value.
      </li>
      <li>
	<b>resume(update=None)</b> method should be invoked on a
	suspended coroutine. <b>wakeup</b> and <b>send</b> are
	synonyms for <em>resume</em>. As explained above, the
	suspended coroutine gets <em>update</em> (any Python object)
	as the value of yield statement that caused it to
	suspend. If <em>resume</em>/<em>wakeup</em>/<em>send</em> is
	called on a coroutine that is not currently
	suspended/sleeping/waiting on receive, the 'update' is queued
	so that when the coroutine next calls suspend, it will receive
	'update' without suspension. Although it is possible to use
	this mechanism as producer/consumer recipe, it is not very
	efficient for high bandwidth use; see chat server in Examples
	section where deque is used along with asyncoro's Event
	locking primitive. If sleep/resume synchronization is needed
	(so that resume waits until specific suspend is ready to
	receive), Event locking primitive can be used so that resuming
	coroutine waits on an event variable and suspending coroutine
	sets the event before going to sleep.
	</li>
      <li>
	<b>set_daemon()</b> method marks the coroutine a daemon
	(process that never terminates). Similar to threading module,
	AsynCoro scheduler waits for all non-daemon coroutines to
	terminate before exiting.
	</li>
      <li>
	<b>throw(exc)</b> method throws exception exc to
	coroutine coro (at the point where it is currently executing).
	</li>
      <li>
	<b>terminate()</b> method terminates the coroutine. This
	is useful, for example, to terminate server processes that
	otherwise never terminate.
	</li>
      <li>
	<b>value()</b> method returns the last value yielded by the
	coroutine, possibly waiting until coroutine terminates. This
	method should not be called from a coroutine - this will cause
	entire coroutine framework to deadlock.  This method is meant
	for main thread in the user program to wait for (main)
	coroutine(s) it creates. If one coroutine needs to wait for
	another to finish, they can use asyncoro's locking primitive
	Event (see below) so first coroutine waits on the event
	variable (with <em>yield</em>) and finishing coroutine sets
	the variable.
	</li>
      <li>
	<b>hot_swappable(flag)</b> method marks if the coroutine's
	generator function can be replaced. This method can be used to
	set (with flag=True) or clear (with flag=False) the flag. With
	hot swapping, specific coroutines' code can be upgraded
	while the application is running.
	</li>
      <li>
	<b>hot_swap(target [, arg1, arg2, ...])</b> method requests
	AsynCoro to replace coroutine's generator function
	with <em>target(arg1, arg2, ...)</em>. AsynCoro then throws
	HotSwap exception in the coroutine when a) coro indicated it
	can handle hot swap (i.e., called hot_swappable with
	flag=True), b) it is currently executing at top-level (i.e.,
	has not called other generator functions) and c) has no
	pending asynchronous operations (socket I/O, tasks scheduled
	with AsyncThreadPool, and database cursor tasks). The new
	generator is set as args[0] of HotSwap exception, so the coro
	can inspect new generator, if necessary, and can do any
	preparation for hot swapping, e.g., saving state (perhaps by
	sending state as a message to itself which can be retrieved in
	the new generator with <em>receive</em>), or even ignore
	HotSwap request. If/when it is ready for swap, it must
	re-raise the same HotSwap exception (with the new generator as
	args[0]). This causes AsynCoro to close current generator,
	replace it with the new generator and schedule new generator
	for execution (from the beginning). Any messages (i.e., resume
	updates) queued in the previous generator are not reset, so
	new generator can process queued messages (e.g.,
	use <em>receive</em> in a loop with timeout=0
	until <em>receive</em> returns alarm_value). Note that
	<em>hot_swap</em> changes generator function of a particular
	coroutine for which it is called. If there are many coroutines
	using that generator function, <em>hot_swap</em> may be called
	for each such coroutine.
	</li>
    </ul>
  </li>
  <li>
    A synchronous (regular) socket <em>sock</em> can be converted to
    asynchronous (non-blocking) socket
    with <b>AsynCoroSocket</b>(sock). SSL can be enabled
    with <b>AsynCoroSocket</b>(sock, keyfile=key, certfile=cert,
    ssl_version=version), where <em>keyfile</em>, <em>certfile</em>
    and <em>ssl_version</em> are as per <em>wrap_socket</em> method
    in <a href="http://docs.python.org/library/ssl.html">ssl
    module</a>. Socket operations <em>accept</em>, <em>connect</em>,
    <em>send</em>, <em>recv</em>, <em>sendall</em>, <em>recvall</em>,
    <em>send_msg</em>, <em>recv_msg</em>, <em>sendto</em>
    and <em>recvfrom</em> for asynchronous sockets must be used with
    'yield' statement. The value of such yield statement is the result
    of the socket I/O operation (for example, for <em>recv</em>, it
    would be the buffer received by the socket). The socket returned
    from <em>accept</em> method of an asynchronous socket is also an
    asynchronous socket, so there is no need to convert it. The
    methods <em>recvall</em>, <em>send_msg</em> and <em>recv_msg</em>
    are available for AsynCoroSocket only - they are not standard
    socket methods: <em>recvall</em> receives exactly given number of
    bytes (counterpart to <em>sendall</em>), <em>send_msg</em>
    prefixes the given buffer with the length so that receiving side
    knows exactly how many bytes to receive, and <em>recv_msg</em>
    receives full message from <em>send_msg</em>.
    </li>
  <li>
    asyncoro
    provides <b>Lock</b>, <b>RLock</b>, <b>Condition</b>, <b>Event</b>
    and <b>Semaphore</b> primitives. They are similar to versions in
    threading module. Any operation that would block in threading
    module is implemented as asynchronous operation in asyncoro. Such
    operations must be called with <em>yield</em> appropriately. For
    example, acquiring a lock may block, so it should be invoked as
    <tt>yield lock.acquire()</tt>. Similarly, Event's wait method or
    Condition's wait method must be used as
    <tt>yield event.wait()</tt> or <tt>yield
    condition.wait()</tt>. For example, Condition variable cv in a
    client should be used as (compare to example at
    <a href="http://docs.python.org/library/threading.html#condition-objects">threading
    module</a>)

    <code>while True:
      yield cv.acquire()
      while not an_item_is_available():
          yield cv.wait()
      get_an_available_item()
      yield cv.release()</code>

    <em>yield</em> is not needed when releasing a lock. However, to be
    cooperative with other coroutines that might be waiting for their
    turn to execute (e.g., waiting to acquire same Condition
    variable), it may be used where appropriate - each <em>yield</em>
    transfers control to asyncoro's scheduler, which may schedule a
    different coroutine that is ready to execute. See documentation
    strings in 'asyncoro.py' for more details on which methods should
    be used with <em>yield</em> and which methods need not be. <br/>
    Technically, locking may not be needed in most cases (where
    'yield' is not used in critical sections), as there is no forced
    preemption with coroutines and at most one coroutine is executing
    at anytime; in fact, the implementation of these primitives in
    asyncoro updates lists and counters without locking.
    </li>
  <li>
    Within a coroutine, generator functions must be called with
    <em>yield</em> statement: If <em>g</em> is a generator function,
    it should be called as <tt>v = yield g()</tt>. Regular
    functions/methods can be called without <em>yield</em>.
    </li>
  <li>
    <b>AsynCoroThreadPool</b> can be used to schedule synchronous,
    time consuming operations with a pool of threads for asynchronous
    completions (similar to sockets). A new thread pool can be created
    with <tt>AsynCoroThreadPool(num_threads)</tt>.  It provides three
    methods:
    <ul>
      <li><b>async_task</b>(coro, target, *args, **kwargs) schedules
	given task, Python function <em>target</em> with
	arguments <em>args</em> and keyword arguments <em>kwargs</em>,
	with the thread pool. This method suspends the calling
	coroutine <em>coro</em>, so it must be used with <em>yield</em>. The
	task is executed in one of the threads in the pool. Once the
	task is complete, <em>coro</em> is resumed with the return
	value from <em>target</em>. Thus, in a
	coroutine <em>coro</em>, the statement
	<tt>v = yield thread_pool.async_task(coro, f, 1)</tt> executes
	function <em>f(1)</em> in a thread and its return value is set
	to <em>v</em>.
      </li>
      <li><b>join()</b> method waits for all scheduled tasks to be
	completed. More tasks can be added if necessary.
      </li>
      <li><b>terminate()</b> method waits for all scheduled tasks to be
	completed and terminates the threads. Tasks added later will
	not be executed.
      </li>
    </ul>
    As coroutines run in a separate thread, any variables shared
    between coroutines and tasks scheduled with thread pool must be
    protected by thread locking (not coroutine locking). As I/O event
    loop is part of AsynCoro scheduler, holding thread locks prevents
    the scheduler from reacting to I/O events quickly, so it is
    expected that if thread locks are used, they are used for very
    brief periods.
    </li>
  <li>
      Database operations are blocking operations and do not provide
      asynchronous notification. asyncoro
      provides <b>AsynCoroDBCursor</b> that
      schedules <em>execute</em>, <em>executemany</em>
      and <em>callproc</em> operations through AsynCoroThreadPool for
      asynchronous completion. Other database operations are
      considered very fast. This interface works with MySQLdb under
      Python version 2.x
      and <a href="https://github.com/petehunt/PyMySQL">pymysql</a>
      under Python version 3.x. If necessary other database interfaces
      and operations can be made asynchronous with AsynCoroThreadPool.
    <p>
      As database connections and cursors are not supposed to be
      shared among threads, AsynCoroDBCursor executes operations on a
      cursor sequentially. Operations on different cursors at the same
      time are run concurrently. A simple example is

      <code># create pool of threads
num_threads = 3
thread_pool = asyncoro.AsynCoroThreadPool(num_threads)
async_cursors = []
for x in range(num_threads):
    conn = MySQLdb.connect(host=host, user=user, passwd=passwd, db=db)
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    # convert cursor to asynchronous cursor using thread_pool to
    # schedule operations
    async_cursors.append(asyncoro.AsynCoroDBCursor(thread_pool, cursor))

# 3 cursors are used in 10 coroutines
for _, async_cursor in itertools.izip(xrange(10), itertools.cycle(async_cursors)):
    asyncoro.Coro(db_proc, async_cursor)

def db_proc(cursor, coro=None):
    # ...
    n = yield cursor.execute(stmt)
    rows = cursor.fetchall()
    # process rows</code>
      </p>
    </li>
  </ul>

<h4>Examples</h4>

See <a href="http://asyncoro.sourceforge.net">asyncoro project</a> for examples.

	  </div>
	</div> 
      </div> 
    </div> 
    <div id="footer"> 
      <p> 
        <a href="http://sourceforge.net/"> 
          Project Web Hosted by <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=539226&amp;type=3" alt="SourceForge.net" /> 
        </a> 
      </p> 
      <p> 
        &copy;Copyright 1999-2009 -
        <a href="http://geek.net" title="Network which provides and promotes Open Source software downloads, development, discussion and news."> 
          Geeknet</a>, Inc., All Rights Reserved
      </p> 
      <p> 
        <a href="http://sourceforge.net/about"> 
          About
        </a> 
        -
        <a href="http://sourceforge.net/tos/tos.php"> 
          Legal
        </a> 
        -
        <a href="http://p.sf.net/sourceforge/getsupport"> 
          Help
        </a> 
      </p> 
    </div> 
  </body> 
</html> 
