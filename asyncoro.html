<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8" /> 
    <meta name="description" content="Python module for distributing computations across multiple processors on a single machine, among many machines in a cluster, grid or cloud. The computations can be standalone programs or python functions." /> 
    <meta name="keywords" content="dispy, python, parallel processing, distributed computing, cluster computing" /> 
    <title> 
      asyncoro - Framework for Asynchronous, Concurrent Programming
    </title> 

<link rel="stylesheet" type="text/css" href="style.css" />
 
  </head> 
  <body> 
    <center><h4>asyncoro : Framework for Asynchronous, Concurrent Programming</h4></center>
    <div id="content-mask">
      <div id="content-container"> 
	<div id="content-menu">
	  <ul>
            <li><a href="index.html">Project Page</a></li> 
            <li><a href="dispy.html">dispy</a></li> 
            <li><a href="dispynode.html">dispynode</a></li> 
            <li><a href="dispyscheduler.html">dispyscheduler</a></li> 
            <li><a href="dispynetrelay.html">dispynetrelay</a></li>
	  </ul>
	  <hr />
	  <ul>
            <li><a href="http://sourceforge.net/projects/dispy/files">Download dispy</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/">Project details</a></li> 
            <li><a href="http://sourceforge.net/projects/dispy/support">Get support</a></li>
	  </ul>
	</div> 

	<div id="content-wrap"> 
	  <div id="content"> 

<center><h2>asyncoro</h2></center>
<p>
  asyncoro, part of
  <a href="http://sourceforge.net/projects/dispy/files">dispy</a>
  package, is a Python framework for developing concurrent programs
  with asynchronous completions and coroutines. Asynchronous
  completions currently implemented in asyncoro are socket I/O
  operations (for non-blocking sockets), database cursors, sleep
  timers and locking primitives.  The coroutines should use 'yield'
  with these completions. Each yield statement gives control to
  asyncoro's scheduler, which interleaves executions of coroutines,
  similar to the way an operating system executes multiple
  processes. Programs developed with asyncoro have same logic and
  structure as programs with threads, except for a few syntactic
  changes. asyncoro supports socket I/O notification mechanisms epoll,
  kqueue, /dev/poll (and poll and select, where necessary), and
  Windows I/O Completion Ports (IOCP) for high performance and
  scalability, and SSL for security.  asyncoro can be used
  independently of dispy.</p>

<h4>Details</h4>
<p>

Traditional methods of threads and synchronous sockets have many
drawbacks, especially with Python due to global interpreter lock (GIL)
that forces only one active thread of execution. This approach is not
suited for large number of concurrent connections, known
as <a href="http://www.kegel.com/c10k.html">C10K problem</a>. In
addition, threads in Python have both memory and time overheads,
especially on multi-core systems
(see <a href="http://www.dabeaz.com/python/GIL.pdf">Inside the Python
GIL</a>).</p>

<p>
  Many <a href="http://nichol.as/asynchronous-servers-in-python">asynchronous
  frameworks</a> are now available to deal with this problem. Unlike
  these frameworks, asyncoro framework is very similar to the thread
  based programming so that there is almost no learning curve -
  existing thread implementations can be converted to asyncoro almost
  mechanically (although it cannot be automated). In fact, it may be
  easier to use asyncoro than threads, as locking is not required with
  asyncoro (see below). Moreover, asyncoro framework is very small
  (about 2000 lines in a single file 'asyncoro.py'), so it is easy to
  understand how it works and how to program with it. While not
  required to program with asyncoro,
  <a href="http://www.dabeaz.com/coroutines/index.html">A Curious
  Course on Coroutines and Concurrency</a> offers details on generator
  functions and coroutines.
</p>

<p>
For example, a simple tcp server with asyncoro looks like:
</p>
<code>def process(sock, coro=None):
    # convert sock to asynchronous socket
    sock = AsynCoroSocket(sock)
    # get (exactly) 4MB of data, for example, and let other coroutines
    # (process methods, in this case) execute in the meantime
    data = yield sock.recvall(4096*1024)
    # ...
    yield sock.sendall(reply)
    sock.close()

if __name__ == '__main__':
    host, port = '', 3456
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(128)
    while True:
        conn, addr = sock.accept()
        Coro(process, conn)
</code>

<p>
Here we mixed synchronous sockets in server loop and asynchronous
sockets in the 'process' method for illustration. The server does not
do any processing, so the loop can quickly accept connections. Each
request is processed in a separate coroutine. Note that I/O event loop
is transparent - asyncoro's scheduler handles I/O events
automatically. A coroutine should have 'coro=None' default
argument. The coroutine builder Coro (which is similar to
threading.Thread) will set coro argument with the Coro instance, which
is used for calling methods in Coro class (see below). In the
'process' method, socket I/O operations are called with 'yield'. With
these statements, the I/O operation is initiated and control goes to
asyncoro's scheduler for scheduling other coroutines as well as
processing I/O events. When an I/O operation is complete, the
scheduler returns the results of the I/O operation back to the
method. During the time it takes to complete an I/O operation, the
scheduler executes other coroutines (in this case, other 'process'
coroutines).
</p>

<h4>API</h4>
<p>
  asyncoro framework consists of AsynCoro scheduler, Coro factory to
  create coroutines from generator functions, AsynCoroSocket to
  convert regular synchronous sockets to asynchronous (non-blocking)
  sockets, AsynCoroDBCursor to convert database cursor
  operations <tt>execute</tt>, <tt>executemany</tt>
  and <tt>callproc</tt>to asynchronous operations, and locking,
  condition, event, semaphore primitives similar to thread
  primitives. asyncoro has been tested with Python versions 2.7 and
  3.2 under Linux, OS X and Windows. Under Windows asyncoro uses IOCP
  only
  if <a href="https://sourceforge.net/projects/pywin32/files/pywin32/">Python
  for Windows Extensions</a> (pywin32) is installed. pywin32 works
  with Windows 32-bit and 64-bit.
  </p>

<ul>
  <li>
    <b>AsynCoro</b> is a (singleton) scheduler that runs coroutines
    similar to operating system's scheduler that runs multiple
    processes. It is initialized when asyncoro module is imported. If
    necessary, the scheduler instance can be obtained
    with <tt>AsynCoro()</tt> or <tt>AsynCoro.instance()</tt>. The
    scheduler runs in a separate thread from user program. It has
    three methods:
    <ul>
      <li>
	<b>cur_coro()</b> method returns coroutine (instance of Coro)
	being executed. As mentioned below, coroutines have 'coro'
	variable (parameter to generator function, to be specific)
	that can be used more efficiently instead.
      </li>
      <li>
	<b>join()</b> method waits for all scheduled non-daemon
	coroutines to finish. After join returns, more coroutines can
	be created (which are added to scheduler).
      </li>
      <li>
	<b>terminate()</b> method terminates all scheduled
	coroutines and then the scheduler itself. If necessary, a new
	scheduler instance may be created with <tt>AsynCoro()</tt>
	or <tt>AsynCoro.instance()</tt>.
      </li>
    </ul>
    </li>
  <li>Threads in synchronous programs can be replaced with coroutines
    using asyncoro's <b>Coro</b> class (i.e., Coro replaces
    threading.Thread). <tt>Coro(target[, arg1, arg2, ...])</tt>
    creates a coroutine. "target" must be a generator function (a
    function with 'yield' statements). "arg1", "arg2" etc. are
    arguments or keyword arguments to "target". "target" generator
    function must have "coro=None" keyword argument. Coro
    instantiation replaces None with the instance of Coro, so
    coroutine can use this to invoke methods in Coro class (see
    below). Consider the generator function (where 'sock' is
    asynchronous socket and all statements are asynchronous, so all
    are used with 'yield')

    <code>def get_reply(sock, msg, coro=None):
    yield sock.sendall(msg)
    yield coro.sleep(1)
    yield sock.recv(1024)</code>
    It can be made a coroutine with
    <tt>Coro(get_reply, conn, "ping")</tt> so that generator function
    get_reply is called with <tt>sock=conn, msg="ping"</tt>. 'coro' keyword
    argument is automatically supplied by Coro; it should not be in
    the arguments to Coro. When a coroutine is created with Coro, it
    is added to AsynCoro scheduler and starts executing - there is no
    need to start it explicitly, as done with threads. Note that
    generator functions cannot use 'return' statement. With asyncoro,
    a <tt>raise StopIteration(v)</tt> effectively serves as <tt>return
    v</tt>. If a generator/coroutine does not use StopIteration, then
    the last value yielded in the generator becomes the return
    value. Thus, in the example above get_reply does not use
    StopIteration, so buffer received (in the last 'yield') is
    equivalent to return value of get_reply.
    </li>
  <li>Within a coroutine, 'coro' variable refers to the coroutine
  (instance of Coro class). This variable can be used to invoke
  methods of Coro class, use it in other coroutines, for example, to
  wakeup from sleep etc. A coroutine has following methods:
    <ul>
      <li><b>suspend(timeout=None, alarm_value=None)</b> method should
      be used with 'yield' statement. <b>sleep</b> method is synonym
      for suspend. If timeout is a positive number (float or int),
      AsynCoro suspends execution of coroutine until that many seconds
      (or fractions of second). If timeout is None, the coroutine is
      not woken up by AsynCoro - some other coroutine needs to resume
      it. The value yielded by this method is the value it is resumed
      with or alarm_value if resumed by AsynCoro due to timeout.  For
      example, if a coroutine executes <tt>v = yield
      coro.sleep(2.9)</tt>, it is suspended for 2.9 seconds. If before
      timeout, another coroutine wakes up this coroutine (with
      "resume" method) with a value, "v" is set to that
      value. Otherwise, after 2.9 seconds, this coroutine is resumed
      with None (default alarm_value) so "v" is set to None and
      coroutine continues execution. During the time coroutine is
      suspended, scheduler executes other scheduled coroutines.
      </li>
      <li>
	<b>resume(update=None)</b> method should be invoked on a
	suspended coroutine. <b>wakeup</b> method is synonym for
	resume. As explained above, the suspended coroutine gets
	"update" (any Python object) as the value of yield statement
	that caused it to suspend. Resume and suspend methods must be
	synchronized - a resume on a coroutine must be for specific
	suspend for that coroutine. If necessary, Event locking
	primitive (see below) can be used so that resuming coroutine
	waits on an event variable and suspending coroutine sets the
	event before going to sleep, so that resume will suspend only
	that suspend.  With suspend/resume methods, coroutines can
	synchronize their executions and possibly exchange data at
	specific execution points.
	</li>
      <li>
	<b>set_daemon()</b> method indicates that coroutine is a
	daemon (process that never terminates). Similar to threading
	module, AsynCoro scheduler waits for all non-daemon coroutines
	to terminate before exiting.
	</li>
      <li>
	<b>throw(exc)</b> method throws exception exc to
	coroutine coro (at the point where it is currently executing).
	</li>
      <li>
	<b>terminate()</b> method terminates the coroutine. This
	is useful, for example, to terminate server processes that
	otherwise never terminate.
	</li>
      <li>
	<b>value()</b> method returns the last value yielded by the
	coroutine, possibly waiting until coroutine terminates. This
	method should not be called from a coroutine - this will cause
	entire coroutine framework to deadlock.  This method is meant
	for main thread in the user program to wait for (main)
	coroutine(s) it creates. If one coroutine needs to wait for
	another to finish, they can use asyncoro's locking primitive
	Event (see below) so first coroutine waits on the event
	variable (with 'yield') and finishing coroutine sets the
	variable.
	</li>
      </ul>
    </li>
  <li>
    A synchronous (regular) socket "sock" can be converted to
    asynchronous (non-blocking) socket
    with <b>AsynCoroSocket</b>(sock). SSL can be enabled
    with <b>AsynCoroSocket</b>(sock, keyfile=key, certfile=cert,
    ssl_version=version), where keyfile, certfile and ssl_version are
    as per wrap_socket method
    in <a href="http://docs.python.org/library/ssl.html">ssl
    module</a>. Socket operations accept, connect, send, recv,
    sendall, recvall, send_msg, recv_msg, sendto and recvfrom for
    asynchronous sockets must be used with 'yield' statement. The
    value of such yield statement is the result of the socket I/O
    operation (for example, for recv, it would be the buffer received
    by the socket). The socket returned from accept method of an
    asynchronous socket is also an asynchronous socket, so there is no
    need to convert it. The methods recvall, send_msg and recv_msg are
    available for AsynCoroSocket only - they are not standard socket
    methods: recvall receives exactly given number of bytes
    (counterpart to sendall), send_msg prefixes the given buffer with
    the length so that receiving side knows exactly how many bytes to
    read, and recv_msg receives full message from send_msg.
    </li>
  <li>
    <b>AsynCoroThreadPool</b> can be used to schedule synchronous,
    time consuming operations with a pool of threads for asynchronous
    completions (similar to sockets). A new thread pool can be created
    with <tt>AsynCoroThreadPool(num_threads)</tt>.  It provides three
    methods:
    <ul>
      <li><b>async_task</b>(coro, target, *args, **kwargs) schedules
	given task, Python function <tt>target</tt> with
	arguments <tt>args</tt> and keyword arguments <tt>kwargs</tt>,
	with the thread pool. This method suspends the calling
	coroutine <tt>coro</tt>, so it must be used with 'yield'. The
	task is executed in one of the threads in the pool. Once the
	task is complete, <tt>coro</tt> is resumed with the return
	value from <tt>target</tt>. Thus, in a
	coroutine <tt>coro</tt>, the statement
	<tt>v = yield thread_pool.async_task(coro, f, 1)</tt> executes
	function <tt>f(1)</tt> in a thread and its return value is set
	to <tt>v</tt>.
      </li>
      <li><b>join()</b> method waits for all scheduled tasks to be
	completed. More tasks can be added if necessary.
      </li>
      <li><b>terminate()</b> method waits for all scheduled tasks to be
	completed and terminates the threads. Tasks added later will
	not be executed.
      </li>
    </ul>
    As coroutines run in a separate thread, any variables shared
    between coroutines and tasks scheduled with thread pool must be
    protected by thread locking (not coroutine locking). As I/O event
    loop is part of AsynCoro scheduler, holding thread locks prevents
    the scheduler from reacting to I/O events quickly, so it is
    expected if thread locks are used, they are used for very brief
    periods.
    </li>
  <li>
    <p>
      Database operations are blocking operations and do not provide
      asynchronous notification. asyncoro
      provides <b>AsynCoroDBCursor</b> that
      schedules <tt>execute</tt>, <tt>executemany</tt>
      and <tt>callproc</tt> operations through AsynCoroThreadPool for
      asynchronous completion. Other database operations are
      considered very fast. This interface works with MySQLdb under
      Python version 2.x
      and <a href="https://github.com/petehunt/PyMySQL">pymysql</a>
      under Python version 3.x. If necessary other database interfaces
      and operations can be made asynchronous with AsynCoroThreadPool.
    </p>
    <p>
      As database connections and cursors are not supposed to be
      shared among threads, asyncoro executes operations on a cursor
      sequentially. Operations on different cursors at the same time
      are run concurrently. A simple example is

      <code># create pool of threads
num_threads = 3
thread_pool = asyncoro.AsynCoroThreadPool(num_threads)
async_cursors = []
for x in range(num_threads):
    conn = MySQLdb.connect(host=host, user=user, passwd=passwd, db=db)
    cursor = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
    # convert cursor to asynchronous cursor using thread_pool to
    # schedule operations
    async_cursors.append(asyncoro.AsynCoroDBCursor(thread_pool, cursor))

# 3 cursors are used in 10 coroutines
for _, async_cursor in itertools.izip(xrange(10), itertools.cycle(async_cursors)):
    asyncoro.Coro(db_proc, async_cursor)

def db_proc(cursor, coro=None):
    # ...
    n = yield cursor.execute(stmt)
    rows = cursor.fetchall()
    # process rows</code>
      </p>
    </li>
  <li>
    asyncoro
    provides <b>Lock</b>, <b>RLock</b>, <b>Condition</b>, <b>Event</b>
    and <b>Semaphore</b> primitives. They are similar to versions in
    threading module. Any operation that would block in threading
    module is implemented as asynchronous operation in asyncoro. Such
    operations must be called with 'yield' appropriately. For example,
    acquiring a lock may block, so it should be invoked as
    <tt>yield lock.acquire()</tt>. Similarly, Event's wait method or
    Condition's wait method must be used as
    <tt>yield event.wait()</tt> or <tt>yield
    condition.wait()</tt>. For example, Condition variable cv in a
    client should be used as (compare to example at
    <a href="http://docs.python.org/library/threading.html#condition-objects">threading
    module</a>)

    <code>while True:
      yield cv.acquire()
      while not an_item_is_available():
          yield cv.wait()
      get_an_available_item()
      yield cv.release()</code>

    'yield' is used when releasing a lock to be cooperative with other
    coroutines that might be waiting for their turn to execute. See
    'asyncoro.py' for more details on which methods should be used
    with 'yield' and which methods need not be. <br/> Technically,
    locking may not be required in most cases (where 'yield' is not
    used in critical sections), as there is no forced preemption with
    coroutines and at most one coroutine is executing at anytime; in
    fact, the implementation of these primitives in asyncoro updates
    lists and counters without locking.
    </li>
  <li>
    Within a coroutine, generator functions must be called with
    'yield' statement: If 'g' is a generator function, it should be
    called as <tt>v = yield g()</tt>.
    </li>
  </ul>

<h4>Examples</h4>
<ul>
  <li>
    <a href="http://sourceforge.net/projects/dispy/files">dispy</a> is
    a framework for parallel execution of computations by distributing
    them to multiple processors on a single node (SMP), nodes in a
    cluster, or large clusters. dispy is implemented with asyncoro, so the
    files in dispy may help understand asyncoro.
  </li>
  <li>
    Following is asyncoro version
    of <a href="http://nichol.as/asynchronous-servers-in-python">Ping Pong
      Benchmark</a> web server, for comparison of both the approach (ease of
    programming) and performance:
<code>import socket
from asyncoro import AsynCoroSocket, Coro, AsynCoro

def process(conn, coro=None):
    conn = AsynCoroSocket(conn)
    yield conn.sendall("HTTP/1.0 200 OK\r\nContent-Length: 5\r\n\r\nPong!\r\n")
    conn.close()

if __name__ == '__main__':
    scheduler = AsynCoro()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('', 8010))
    sock.listen(5000)

    while True:
        try:
            conn, addr = sock.accept()
        except KeyboardInterrupt:
            break
        Coro(process, conn)
    scheduler.terminate()
</code>
  </li>
  </ul>

	  </div>
	</div> 
      </div> 
    </div> 
    <div id="footer"> 
      <p> 
        <a href="http://sourceforge.net/"> 
          Project Web Hosted by <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=539226&amp;type=3" alt="SourceForge.net" /> 
        </a> 
      </p> 
      <p> 
        &copy;Copyright 1999-2009 -
        <a href="http://geek.net" title="Network which provides and promotes Open Source software downloads, development, discussion and news."> 
          Geeknet</a>, Inc., All Rights Reserved
      </p> 
      <p> 
        <a href="http://sourceforge.net/about"> 
          About
        </a> 
        -
        <a href="http://sourceforge.net/tos/tos.php"> 
          Legal
        </a> 
        -
        <a href="http://p.sf.net/sourceforge/getsupport"> 
          Help
        </a> 
      </p> 
    </div> 
  </body> 
</html> 
